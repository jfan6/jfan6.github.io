"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HTTPSignature = void 0;
const node_crypto_1 = __importDefault(require("node:crypto"));
class HTTPSignature {
    static generateSignatureString(signature, headers, requestMethod, requestUrl) {
        const data = signature.headers
            .map((header) => {
            return `${header}: ${this.getHeader(header, headers, requestMethod, requestUrl)}`;
        })
            .join('\n');
        return data;
    }
    static parseSignatureHeader(signature) {
        const signatureData = signature
            .split(',')
            .reduce((data, str) => {
            try {
                const [key, value] = str.split('=');
                return {
                    // values are wrapped in quotes like key="the value"
                    [key]: value.replace(/"/g, ''),
                    ...data
                };
            }
            catch (err) {
                return data;
            }
        }, {});
        if (!signatureData.signature ||
            !signatureData.headers ||
            !signatureData.keyId ||
            !signatureData.algorithm) {
            throw new Error('Could not parse signature');
        }
        return {
            keyId: new URL(signatureData.keyId),
            headers: signatureData.headers.split(/\s/),
            signature: Buffer.from(signatureData.signature, 'base64url'),
            algorithm: signatureData.algorithm
        };
    }
    static getHeader(header, headers, requestMethod, requestUrl) {
        if (header === '(request-target)') {
            return `${requestMethod.toLowerCase()} ${requestUrl}`;
        }
        if (!headers.has(header)) {
            throw new Error(`Missing Header ${header}`);
        }
        return headers.get(header);
    }
    static async getPublicKey(keyId) {
        try {
            const keyRes = await fetch(keyId, {
                headers: {
                    Accept: 'application/ld+json'
                }
            });
            // This whole thing is wrapped in try/catch so we can just cast as we want and not worry about errors
            const json = (await keyRes.json());
            const key = node_crypto_1.default.createPublicKey(json.publicKey.publicKeyPem);
            return key;
        }
        catch (err) {
            throw new Error(`Could not find public key ${keyId.href}: ${err}`);
        }
    }
    static validateDigest(signatureData, requestBody, requestHeaders) {
        const digest = node_crypto_1.default
            .createHash(signatureData.algorithm)
            .update(requestBody)
            .digest('base64');
        const remoteDigest = requestHeaders.get('digest')?.split('SHA-256=')[1];
        return digest === remoteDigest;
    }
    static async validate(requestMethod, requestUrl, requestHeaders, requestBody = Buffer.alloc(0, 0)) {
        const signatureHeader = requestHeaders.get('signature');
        if (typeof signatureHeader !== 'string') {
            throw new Error('Invalid Signature header');
        }
        const signatureData = this.parseSignatureHeader(signatureHeader);
        if (requestMethod.toLowerCase() === 'post') {
            const digestIsValid = this.validateDigest(signatureData, requestBody, requestHeaders);
            if (!digestIsValid) {
                return false;
            }
        }
        const publicKey = await this.getPublicKey(signatureData.keyId);
        const signatureString = this.generateSignatureString(signatureData, requestHeaders, requestMethod, requestUrl);
        const verified = node_crypto_1.default
            .createVerify(signatureData.algorithm)
            .update(signatureString)
            .verify(publicKey, signatureData.signature);
        return verified;
    }
    static async sign(request, keyId, privateKey) {
        let headers;
        if (request.method.toLowerCase() === 'post') {
            headers = ['(request-target)', 'host', 'date', 'digest'];
        }
        else {
            headers = ['(request-target)', 'host', 'date'];
        }
        const signatureData = {
            signature: Buffer.alloc(0, 0),
            headers,
            keyId,
            algorithm: 'rsa-sha256'
        };
        const url = new URL(request.url);
        const signatureString = this.generateSignatureString(signatureData, request.headers, request.method, url.pathname);
        const signature = node_crypto_1.default
            .createSign(signatureData.algorithm)
            .update(signatureString)
            .sign(privateKey)
            .toString('base64');
        const newHeaders = new Headers(request.headers);
        newHeaders.set('Signature', `keyId="${keyId}",headers="${headers.join(' ')}",signature="${signature}",algorithm="${signatureData.algorithm}"`);
        return new Request(request, {
            headers: newHeaders
        });
    }
}
exports.HTTPSignature = HTTPSignature;
//# sourceMappingURL=http-signature.service.js.map