"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_crypto_1 = __importDefault(require("node:crypto"));
const actor_entity_1 = require("./actor.entity");
const http_signature_service_1 = require("./http-signature.service");
const node_assert_1 = __importDefault(require("node:assert"));
describe('Actor', function () {
    describe('#sign', function () {
        it('returns a request with a valid Signature header', async function () {
            const keypair = node_crypto_1.default.generateKeyPairSync('rsa', {
                modulusLength: 512
            });
            const baseUrl = new URL('https://example.com/ap');
            const actor = actor_entity_1.Actor.create({
                username: 'Testing',
                outbox: [],
                publicKey: keypair.publicKey
                    .export({ type: 'pkcs1', format: 'pem' })
                    .toString(),
                privateKey: keypair.privateKey
                    .export({ type: 'pkcs1', format: 'pem' })
                    .toString()
            });
            const url = new URL('https://some-server.com/users/username/inbox');
            const date = new Date();
            const request = new Request(url, {
                headers: {
                    Host: url.host,
                    Date: date.toISOString(),
                    Accept: 'application/ld+json; profile="https://www.w3.org/ns/activitystreams"'
                }
            });
            const signedRequest = await actor.sign(request, baseUrl);
            const publicKey = actor.getJSONLD(baseUrl).publicKey;
            class MockHTTPSignature extends http_signature_service_1.HTTPSignature {
                static async getPublicKey() {
                    return node_crypto_1.default.createPublicKey(publicKey.publicKeyPem);
                }
            }
            const signedRequestURL = new URL(signedRequest.url);
            const actual = await MockHTTPSignature.validate(signedRequest.method, signedRequestURL.pathname, signedRequest.headers);
            const expected = true;
            node_assert_1.default.equal(actual, expected, 'The signature should have been valid');
        });
    });
});
//# sourceMappingURL=actor.entity.test.js.map